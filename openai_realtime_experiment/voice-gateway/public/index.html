<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Voice Agent Test</title>
    <style>
      :root { color-scheme: light dark; }
      body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 2rem; max-width: 900px; }
      .card { border: 1px solid #3a3a3a40; border-radius: 12px; padding: 16px; margin-bottom: 16px; backdrop-filter: blur(2px); }
      .row { display: flex; align-items: center; gap: 12px; margin: 8px 0; }
      select, button { padding: 10px 12px; border-radius: 8px; border: 1px solid #3a3a3a40; background: inherit; color: inherit; }
      button.primary { background: #3b82f6; color: white; border: none; }
      button:disabled { opacity: 0.5; }
      #log { white-space: pre-wrap; background: #0b0b0b; color: #eaeaea; padding: 12px; border-radius: 8px; height: 220px; overflow: auto; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; }
      #meter { width: 220px; height: 10px; background: #333; border-radius: 6px; position: relative; overflow: hidden; }
      #meter > span { display: block; height: 100%; width: 0%; background: linear-gradient(90deg, #22c55e, #ef4444); transition: width 80ms linear; }
    </style>
  </head>
  <body>
    <h1>Voice Agent (WebRTC) Test</h1>
    <div class="card">
      <div class="row">
        <label for="mic">Microphone</label>
        <select id="mic"></select>
        <div id="meter"><span></span></div>
      </div>
      <div class="row">
        <button id="connect" class="primary">Connect</button>
        <button id="disconnect" disabled>Disconnect</button>
      </div>
    </div>
    <div class="card">
      <div id="log"></div>
    </div>

    <script type="module">
      let pc;
      let micStream;
      let audioContext;
      let analyser;
      let meterRAF;
      const logEl = document.getElementById('log');
      const connectBtn = document.getElementById('connect');
      const disconnectBtn = document.getElementById('disconnect');
      const micSelect = document.getElementById('mic');
      const meterBar = document.querySelector('#meter > span');

      function log(...args) {
        const line = args.map(a => typeof a === 'string' ? a : JSON.stringify(a)).join(' ');
        logEl.textContent += line + '\n';
        logEl.scrollTop = logEl.scrollHeight;
      }

      async function populateDevices() {
        try {
          // Request a temporary stream to get labels on devices
          const tmp = await navigator.mediaDevices.getUserMedia({ audio: true });
          const devices = await navigator.mediaDevices.enumerateDevices();
          const mics = devices.filter(d => d.kind === 'audioinput');
          micSelect.innerHTML = '';
          for (const d of mics) {
            const opt = document.createElement('option');
            opt.value = d.deviceId;
            opt.textContent = d.label || `Microphone (${d.deviceId.slice(0,6)}...)`;
            micSelect.appendChild(opt);
          }
          tmp.getTracks().forEach(t => t.stop());
        } catch (e) {
          log('Device enumeration error', e);
        }
      }

      function startMeter(stream) {
        try {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
          const source = audioContext.createMediaStreamSource(stream);
          analyser = audioContext.createAnalyser();
          analyser.fftSize = 256;
          source.connect(analyser);
          const data = new Uint8Array(analyser.frequencyBinCount);
          const tick = () => {
            analyser.getByteTimeDomainData(data);
            let peak = 0;
            for (let i = 0; i < data.length; i++) {
              const v = Math.abs(data[i] - 128) / 128;
              if (v > peak) peak = v;
            }
            meterBar.style.width = Math.min(100, Math.round(peak * 100)) + '%';
            meterRAF = requestAnimationFrame(tick);
          };
          meterRAF = requestAnimationFrame(tick);
        } catch {}
      }

      function stopMeter() {
        if (meterRAF) cancelAnimationFrame(meterRAF);
        meterBar.style.width = '0%';
        try { audioContext && audioContext.close(); } catch {}
        audioContext = undefined;
      }

      async function connect() {
        connectBtn.disabled = true;
        try {
          const deviceId = micSelect.value || 'default';
          micStream = await navigator.mediaDevices.getUserMedia({ audio: { deviceId } });
          pc = new RTCPeerConnection();
          micStream.getTracks().forEach(track => pc.addTrack(track, micStream));
          startMeter(micStream);

          const audioEl = new Audio();
          audioEl.autoplay = true;
          pc.ontrack = (e) => {
            audioEl.srcObject = e.streams[0];
          };

          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);

          const resp = await fetch('/realtime/sdp', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ sdp: offer.sdp })
          });
          const answerSdp = await resp.text();
          await pc.setRemoteDescription({ type: 'answer', sdp: answerSdp });
          disconnectBtn.disabled = false;
          log('Connected');
        } catch (e) {
          log('Connect error', e);
          connectBtn.disabled = false;
        }
      }

      async function disconnect() {
        disconnectBtn.disabled = true;
        try {
          if (pc) pc.close();
          if (micStream) micStream.getTracks().forEach(t => t.stop());
          stopMeter();
          log('Disconnected');
        } finally {
          connectBtn.disabled = false;
        }
      }

      connectBtn.addEventListener('click', connect);
      disconnectBtn.addEventListener('click', disconnect);
      populateDevices();
    </script>
  </body>
  </html>


